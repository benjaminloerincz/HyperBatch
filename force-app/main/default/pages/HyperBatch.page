<apex:page controller="HyperBatchCon" showHeader="false" sidebar="false" applyHtmlTag="false" applyBodyTag="false">
    <html xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" lang="en">
        <head>
            <script src="https://code.jquery.com/jquery-1.12.4.min.js" />
            <script src="../../soap/ajax/37.0/connection.js" type="text/javascript" />

            <apex:stylesheet value="{!URLFOR($Resource.slds, 'assets/styles/salesforce-lightning-design-system-vf.css')}" />
            <script type="text/javascript">
                document.title = "HyperBatch";

                Visualforce.remoting.timeout = 120000; // Set timeout at page level

                //=====================================
                // patching one function in the connection.js resource, so we don't get
                // Refused to set unsafe header "User-Agent" errror
                //=====================================

                sforce.Transport = function (url) {
                    this.url = url;
                    this.connection = null;

                    this.newConnection = function () {
                        try {
                            this.connection = new ActiveXObject("Msxml2.XMLHTTP");
                        } catch (e) {
                            try {
                                this.connection = new ActiveXObject("Microsoft.XMLHTTP");
                            } catch (e) {
                                this.connection = new XMLHttpRequest();
                            }
                        }

                        return this.connection;
                    };

                    this.send = function (envelope, callback, async, timeout) {
                        this.newConnection();
                        if (async) {
                            this.connection.onreadystatechange = this.httpConnectionCallback;
                        }
                        var holder = new sforce.internal.ConnectionHolder(this.connection, callback);
                        sforce.internal._connections.push(holder);
                        this.connection.open("POST", this.url, async);
                        this.connection.setRequestHeader("Content-Type", "text/xml; charset=UTF-8");
                        this.connection.setRequestHeader("SOAPAction", '""');
                        this.connection.setRequestHeader("Accept", "text/xml");
                        //this.connection.setRequestHeader("User-Agent", "SFAJAX 1.0"); //here is the one line we are patching
                        this.connection.send(envelope);
                        if (async && typeof timeout !== "undefined") {
                            this.setTimeoutOn(holder, timeout);
                        }
                        if (!async) {
                            this.httpConnectionCallback();
                        }
                    };

                    this.setTimeoutOn = function (holder, timeout) {
                        function abortConnection() {
                            if (holder.connection.readyState !== 4) {
                                holder.timedout = true;
                                holder.connection.abort();
                            }
                        }
                        setTimeout(abortConnection, timeout);
                    };

                    this.httpConnectionCallback = function () {
                        for (var i = 0; i < sforce.internal._connections.length; i++) {
                            var holder = sforce.internal._connections[i];
                            if (holder !== null) {
                                if (holder.timedout) {
                                    sforce.internal._connections[i] = null;
                                    sforce.internal._connections.slice(i, 1);
                                    holder.callback.httpCallback("Remote invocation timed out", false);
                                } else if (holder.connection.readyState == 4) {
                                    sforce.internal._connections[i] = null;
                                    sforce.internal._connections.slice(i, 1);
                                    var success = holder.connection.status == 200;
                                    if (sforce.debug.trace) {
                                        sforce.debug.log("Response : status - " + holder.connection.status);
                                        sforce.debug.logXml(holder.connection.responseText);
                                    }
                                    if (sforce.debug.apexTrace) {
                                        sforce.debug.logApex(holder.connection.responseText);
                                    }
                                    if (holder.connection.responseXML && holder.connection.responseXML.documentElement) {
                                        holder.callback.httpCallback(holder.connection.responseXML.documentElement, success);
                                    } else {
                                        holder.callback.httpCallback(
                                            "Remote invocation failed, due to: " + holder.connection.responseText + " status code: ",
                                            holder.connection.status
                                        );
                                    }
                                }
                            }
                        }
                    };
                };

                //END PATCH =======================================

                var hyperBatchClasses = [];
                var batchClassMap = {};

                getApexClasses();

                function renderClasses() {
                    var classes =
                        '<table id="classes" class="slds-table slds-table--bordered slds-table--cell-buffer">' +
                        "<thead>" +
                        '<tr class="slds-text-title--caps">' +
                        '<th scope="col"></th>' +
                        '<th scope="col">' +
                        '<div class="slds-truncate" title="HyperBatch Class">HyperBatch Class</div>' +
                        "</th>" +
                        "</tr>" +
                        "</thead>" +
                        "<tbody>";

                    for (var i = 0; i < hyperBatchClasses.length; i++) {
                        classes +=
                            "<tr>" +
                            '<td><input type="checkbox" id="chk_' +
                            hyperBatchClasses[i] +
                            '" value="' +
                            hyperBatchClasses[i] +
                            '"/></td>' +
                            '<td><div class="slds-truncate" title="' +
                            hyperBatchClasses[i] +
                            '">' +
                            hyperBatchClasses[i] +
                            "</div></td>" +
                            "</tr>";
                    }

                    classes += "</tbody></table>";
                    $("#classes").html(classes);
                }

                function handleRun(isAsync) {
                    //get the checkboxes for the batch classes selected
                    var selectedClasses = [];
                    $("#classes :checked").each(function () {
                        selectedClasses.push($(this).val());
                    });
                    console.log(selectedClasses);

                    //add a status column for the batch
                    for (var i = 0; i < selectedClasses.length; i++) {
                        addStatusColumn(selectedClasses[i], isAsync);
                    }

                    //run the batch asynchronously
                    for (var i = 0; i < selectedClasses.length; i++) {
                        getQuery(selectedClasses[i], isAsync);
                    }
                }

                function runAsync() {
                    handleRun(true);
                }

                function runSync() {
                    handleRun(false);
                }

                function addStatusColumn(batchClassName, isAsync) {
                    var divId = "status_" + batchClassName;
                    var divWrapId = "artWrap_" + batchClassName;

                    //lookhere
                    var iconURL;
                    if (isAsync) {
                        iconURL = "{!URLFOR($Resource.slds, 'assets/icons/utility-sprite/svg/symbols.svg#standard_objects')}";
                    } else {
                        iconURL = "{!URLFOR($Resource.slds, 'assets/icons/utility-sprite/svg/symbols.svg#sync')}";
                    }

                    var mode =
                        '<svg aria-hidden="true" class="slds-button__icon slds-button__icon--left" style="width:1rem; height:1rem;">' +
                        '<use xlink:href="' +
                        iconURL +
                        '"></use>' +
                        "</svg>";

                    var chunkSize = $("#chunkSize").val();

                    //remove it if it exists
                    if ($("#" + divWrapId).length) {
                        //remove it
                        $("#" + divWrapId).remove();
                    }

                    //add it
                    var col =
                        '<div id="artWrap_' +
                        batchClassName +
                        '">' +
                        '<article id="art_' +
                        batchClassName +
                        '" class="slds-card">' +
                        '<header class="slds-media slds-media--center slds-has-flexi-truncate">' +
                        "<h2> " +
                        mode +
                        ' <span class="slds-text-heading--small">' +
                        batchClassName +
                        " (" +
                        chunkSize +
                        ")</span></h2>" +
                        "</header>" +
                        '<div id="' +
                        divId +
                        '"/>' +
                        "</article>" +
                        "</div>";
                    $("#statusColumns").append(col);
                }

                function getQuery(batchClassName, isAsync) {
                    batchClassMap[batchClassName] = {};
                    batchClassMap[batchClassName].startTimestamp = new Date().getTime();
                    batchClassMap[batchClassName].chunkSize = $("#chunkSize").val();

                    if (!isAsync) {
                        //sync will store the state in this object
                        batchClassMap[batchClassName].state = {};
                    }

                    Visualforce.remoting.Manager.invokeAction(
                        "{!$RemoteAction.HyperBatchCon.getHyperBatchStart}",
                        batchClassName,
                        isAsync,
                        function (result, event) {
                            console.log("getQuery result, event");
                            console.log(result);
                            console.log(event);

                            batchClassMap[result.batchClassName].objName = result.HyperBatchStart.objectName;
                            batchClassMap[result.batchClassName].query = result.HyperBatchStart.query;
                            batchClassMap[result.batchClassName].isAsync = result.isAsync;

                            chunkEntireObject(result.batchClassName);
                        },
                        { escape: false, buffer: false }
                    );
                }

                function executeStart(objName) {
                    console.log("executeStart: " + objName);
                    parallelStart(objName);
                }

                //=========================================================
                // BEGIN Query Locator PK Chunking
                //=========================================================

                //Set AJAX timeout to 15 mins (conversion to MS)
                var AJAXtimeout = 15 * (60 * 1000);

                sforce.connection.sessionId = "{!$Api.Session_ID}";
                var chunkList = {};
                var offsetIdMap = {};
                var totalQueryMoreSize = {};
                var totalQueriesCompleted = {};
                var objectQueriesCompleted = {};
                var objectAllQueriesCompleted = {};

                function successQueryMore(context, result) {
                    console.log("successQueryMore result");
                    console.log(result);

                    var batchClassName = context.batchClassName;
                    var resultValues = getResultValues(result, batchClassName);
                    var chunkSize = batchClassMap[batchClassName].chunkSize;

                    //add the first result to our object before we fire off all the subsequent ones in parallel
                    if (batchClassName in offsetIdMap) {
                        offsetIdMap[batchClassName][resultValues.offset] = resultValues;
                    } else {
                        offsetIdMap[batchClassName] = {};
                        offsetIdMap[batchClassName][resultValues.offset] = resultValues;
                    }

                    if (resultValues.totalSize == 0) {
                        totalQueryMoreSize[batchClassName] = 0;
                        allQueriesComplete(batchClassName);
                    } else if (resultValues.totalSize > 0 && resultValues.totalSize <= 2000) {
                        //this means there is no cursor Id, we got all the records returned to us
                        //chunk is just the first and last Id in the locator, jump right to success
                        totalQueryMoreSize[batchClassName] = 1;
                        qmSuccess(context, result);
                    } else {
                        //> 2000 records means that we need to chunk

                        //get the loop size
                        var loopSize = Math.floor(resultValues.totalSize / chunkSize);

                        //we need to know ahead of time how many times we are going to call doQueryMore, so when the
                        //results come back async, we know if we are done or not
                        totalQueryMoreSize[batchClassName] = loopSize;

                        //in case it didn't divide evenly, will have to fire off one more query of a custom size
                        //the offset will be the total number of records in the querylocator minus the leftover
                        //EX: 100,002, R=2, offset = 100,002 - 2 = 100,000
                        var remainder = resultValues.totalSize % chunkSize;

                        //in some cases we don't need another queryMore for the remainder.
                        //if total records - running total is less than chunk size, the last id query will get us everything
                        var runningTotal = chunkSize * loopSize;
                        if (resultValues.totalSize - runningTotal < chunkSize) {
                            remainder = 0;
                        }

                        //if the chunks divide perfectly into the totalSize, subtract one from the loopsize
                        //otherwise we will be requesting an offset that doesn't exist at the end.
                        if (resultValues.totalSize - runningTotal == 0) {
                            loopSize--;
                            totalQueryMoreSize[batchClassName]--;
                        }

                        if (remainder > 0) {
                            totalQueryMoreSize[batchClassName]++;
                        }

                        //add in one more for the query of the last Id
                        totalQueryMoreSize[batchClassName]++;

                        //fire off all the queryMore's for loopSize
                        for (var i = 1; i <= loopSize; i++) {
                            var offset = chunkSize * i;
                            doQueryMore(resultValues.cursorId, offset, context);
                        }

                        //fire off one more if there was a remainder
                        if (remainder > 0) {
                            var offset = resultValues.totalSize - remainder;
                            doQueryMore(resultValues.cursorId, offset, context);
                        }

                        //now fire off one more to get the last Id in the cursor
                        var offset = resultValues.totalSize - 1;
                        doQueryMore(resultValues.cursorId, offset, context);
                    }
                }

                function chunkEntireObject(batchClassName) {
                    chunkList[batchClassName] = [];
                    objectQueriesCompleted[batchClassName] = 0;
                    objectAllQueriesCompleted[batchClassName] = false;

                    totalQueriesCompleted[batchClassName] = 0;

                    var SOQL = "SELECT Id FROM " + batchClassMap[batchClassName].objName + " ORDER BY Id";
                    console.log("SOQL: " + SOQL);

                    var handleSuccess = function (result) {
                        console.log("chunkEntireObject success");
                        console.log("this");
                        console.log(this);
                        console.log("result");
                        console.log(result);
                        successQueryMore(this, result);
                    };
                    var handleFailure = function (error) {
                        console.log("chunkEntireObject error");
                        console.log(error);
                        console.log("this");
                        console.log(this);

                        var qErr = {};
                        qErr.status = false;
                        qErr.type = "exception";
                        qErr.message = "Problem getting query locator: " + error + ".  " + this.batchClassName;
                    };
                    var context = { batchClassName: batchClassName };
                    var handleSuccessWithContext = handleSuccess.bind(context);
                    var handleFailureWithContext = handleFailure.bind(context);
                    var callback = { onSuccess: handleSuccessWithContext, onFailure: handleFailureWithContext, timeout: AJAXtimeout };
                    var result = sforce.connection.query(SOQL, callback);
                }

                function doQueryMore(cursorId, offset, context) {
                    var ql = cursorId + "-" + offset;
                    console.log("queryMore ql");
                    console.log(ql);

                    var handleSuccess = function (result) {
                        console.log("doQueryMore success");
                        console.log("this");
                        console.log(this);
                        console.log("result");
                        console.log(result);

                        qmSuccess(context, result);
                    };
                    var handleFailure = function (error) {
                        console.log("doQueryMore error");
                        console.log(error);
                        console.log("this");
                        console.log(this);

                        var qErr = {};
                        qErr.status = false;
                        qErr.type = "exception";
                        qErr.message = "queryMore problem: " + error + ".  " + this.batchClassName;
                    };
                    var context = { batchClassName: context.batchClassName };
                    var handleSuccessWithContext = handleSuccess.bind(context);
                    var handleFailureWithContext = handleFailure.bind(context);
                    var callback = { onSuccess: handleSuccessWithContext, onFailure: handleFailureWithContext, timeout: AJAXtimeout };
                    var result = sforce.connection.queryMore(ql, callback);
                }

                function qmSuccess(context, result) {
                    var batchClassName = context.batchClassName;
                    console.log("qmSuccess context, result");
                    console.log(context);
                    console.log(result);

                    var resultValues = getResultValues(result, batchClassName);

                    console.log("resultValues");
                    console.log(resultValues);

                    if (batchClassName in offsetIdMap) {
                        offsetIdMap[batchClassName][resultValues.offset] = resultValues;
                    } else {
                        offsetIdMap[batchClassName] = {};
                        offsetIdMap[batchClassName][resultValues.offset] = resultValues;
                    }
                    totalQueriesCompleted[batchClassName]++;

                    console.log(totalQueryMoreSize[batchClassName] + ", " + totalQueriesCompleted[batchClassName]);
                    if (totalQueryMoreSize[batchClassName] == totalQueriesCompleted[batchClassName]) {
                        allQueriesComplete(batchClassName);
                    }
                }

                function getResultValues(result, batchClassName) {
                    var retObj = {};
                    retObj.totalSize = -1;
                    retObj.cursorId = "";
                    retObj.offset = 999999999999; //~1T records.  using this to put last result at the end of the sort, its QL will be null
                    retObj.firstRecordId = "";
                    retObj.lastRecordId = "";
                    retObj.type = batchClassName;

                    console.log("getResultValues result");
                    console.log(result);

                    //get the querylocator from the result
                    var ql = result.queryLocator;

                    //ql will look like this:
                    //01gJ000000IYnYLIA1-2000

                    //split the ql into cursorId and offset
                    if (ql != null) {
                        //if there are no more records to get, ql will be null
                        var arrQL = ql.split("-");
                        if (arrQL.length == 2) {
                            retObj.cursorId = arrQL[0];
                            retObj.offset = arrQL[1];
                        }
                    }

                    //get the total size, convert to int
                    retObj.totalSize = parseInt(result["size"]);

                    //get the first record Id
                    var firstRecordFound = false;
                    if ("records" in result) {
                        //see if it is in an array
                        if (Object.prototype.toString.call(result.records) === "[object Array]") {
                            if (result.records.length > 0) {
                                retObj.firstRecordId = result.records[0].Id;
                                firstRecordFound = true;
                            }
                        } else {
                            //or else just a single object
                            if ("Id" in result.records) {
                                retObj.firstRecordId = result.records.Id;
                                firstRecordFound = true;
                            }
                        }
                    }

                    //get the last record Id
                    var lastRecordFound = false;
                    if ("records" in result) {
                        //see if it is in an array
                        if (Object.prototype.toString.call(result.records) === "[object Array]") {
                            if (result.records.length > 0) {
                                retObj.lastRecordId = result.records[result.records.length - 1].Id;
                                lastRecordFound = true;
                            }
                        } else {
                            //or else just a single object
                            if ("Id" in result.records) {
                                retObj.lastRecordId = result.records.Id;
                                lastRecordFound = true;
                            }
                        }
                    }

                    console.log("retObj");
                    console.log(retObj);

                    return retObj;
                }

                function allQueriesComplete(type) {
                    //build an array of all the keys so we can sort them
                    var offsetArray = [];
                    for (var offset in offsetIdMap[type]) {
                        offsetArray.push(parseInt(offset));
                    }

                    offsetArray.sort(function (a, b) {
                        return a - b;
                    });

                    //loop from the beginning to the next to last one
                    //don't need the last since it just contains the very last Id - special case

                    if (offsetArray.length == 1) {
                        var range = {};

                        range.first = offsetIdMap[type][offsetArray[0]].firstRecordId;
                        range.last = offsetIdMap[type][offsetArray[0]].lastRecordId;
                        range.isLast = true;
                        chunkList[type].push(range);
                    } else {
                        for (var i = 0; i < offsetArray.length - 1; i++) {
                            var range = {};
                            range.first = "";
                            range.last = "";
                            range.isLast = false;

                            var currOffset = offsetArray[i];
                            var nextOffset = offsetArray[i + 1];
                            range.first = offsetIdMap[type][currOffset].firstRecordId;

                            var lastLoop = false;
                            if (i == offsetArray.length - 2) {
                                lastLoop = true;
                            }

                            if (lastLoop) {
                                range.isLast = true;

                                //the last Id will be the actual last Id from the very last chunk
                                range.last = offsetIdMap[type][nextOffset].lastRecordId;
                            } else {
                                //the last Id will be the first from the next chunk (have to use < logic)
                                range.last = offsetIdMap[type][nextOffset].firstRecordId;
                            }
                            chunkList[type].push(range);
                        }
                    }

                    console.log("chunkList");
                    console.log(chunkList);

                    //loop through and add a unique identifier to every chunk, as well as it's index location
                    //starting with 1.  for messaging purposes
                    for (var i = 0; i < chunkList[type].length; i++) {
                        chunkList[type][i].guid = generateUUID();
                        chunkList[type][i].num = i + 1;
                        chunkList[type][i].total = chunkList[type].length;
                    }

                    console.log("*** QLPK done***");

                    //now kick off the chunk queries
                    executeStart(type);
                }

                //=========================================================
                // END Query Locator PK Chunking
                //=========================================================

                //=========================================================
                // BEGIN execute chunks
                //=========================================================

                //TODO: make these variables we can pass in
                var numSimultaneous = 1000;
                var numberOfRetries = 15;

                var chunkRetries = {};
                var startTimestamp = {};

                var numTotal = {};
                var numRemainingTotal = {};
                var numRemainingBatch = {};
                var allRecordsReceived = {};

                function parallelStart(type) {
                    console.log("parallelStart: " + type);
                    console.log("chunkList");
                    console.log(chunkList);

                    numTotal[type] = chunkList[type].length;
                    numRemainingTotal[type] = numTotal[type];
                    numRemainingBatch[type] = 0;
                    //allRecords[type] = {};
                    allRecordsReceived[type] = false;

                    getNextBatch(type);
                }

                function getNextBatch(type) {
                    console.log("getNextBatch type: " + type);
                    console.log("getNextBatch numRemainingBatch: ");
                    console.log(numRemainingBatch);

                    /*
                      console.log('getNextBatch numTotal[type]');
                      console.log(numTotal[type]);

                      console.log('getNextBatch numRemainingBatch[type]');
                      console.log(numRemainingBatch[type]);
                      */

                    if (numRemainingTotal[type] == 0) {
                        parallelEnd(type);
                    } else {
                        var nextBatchStartIndex = numTotal[type] - numRemainingTotal[type];

                        //get the number of simultaneous chunks, or whatever is left if it's less
                        numRemainingBatch[type] = numSimultaneous;
                        if (numRemainingTotal[type] < numRemainingBatch[type]) {
                            numRemainingBatch[type] = numRemainingTotal[type];
                        }
                        chunkWorker(nextBatchStartIndex, numRemainingBatch, type);
                    }
                }

                function chunkWorker(nextBatchStartIndex, numRemainingBatch, type) {
                    for (var i = 0; i < numRemainingBatch[type]; i++) {
                        updateStatus(1, "Data Requested (" + type + "): " + (nextBatchStartIndex + i + 1) + "/" + numTotal[type] + ". ");
                        addBatchStatus(type, chunkList[type][nextBatchStartIndex + i]);
                        doChunk(nextBatchStartIndex + i, type);
                    }
                }

                function chunkComplete(context, response) {
                    var batchClassName = context.batchClassName;

                    if (!response.isAsync) {
                        //sync response, need to save off the state
                        if ("state" in response) {
                            batchClassMap[batchClassName].state[context.num] = response.state;
                        }

                        //update the status
                        //lookhere
                    }

                    numRemainingBatch[batchClassName]--;
                    numRemainingTotal[batchClassName]--;

                    updateStatus(
                        2,
                        "Received (" +
                            batchClassName +
                            "): " +
                            (numTotal[batchClassName] - numRemainingTotal[batchClassName]) +
                            "/" +
                            numTotal[batchClassName] +
                            "."
                    );
                    updateBatchStatus(context, response);

                    if (numRemainingBatch[batchClassName] == 0) {
                        getNextBatch(batchClassName);
                    }
                }

                function parallelEnd(type) {
                    if (batchClassMap[type].isAsync) {
                        checkAsyncJobs(type);
                    } else {
                        runBatchFinish(type);
                    }
                }

                function checkAsyncJobs(type) {
                    var finalStatuses = ["Aborted", "Completed", "Failed"];

                    //get all the unfinished job Ids
                    var jobIds = [];
                    for (var i = 0; i < chunkList[type].length; i++) {
                        var chunk = chunkList[type][i];
                        if ("jobId" in chunk) {
                            if (chunk.jobId != null) {
                                var doUpdate = false;
                                if ("AsyncApexJobStatus" in chunk) {
                                    if (finalStatuses.indexOf(chunk.AsyncApexJobStatus) == -1) {
                                        doUpdate = true;
                                    }
                                } else {
                                    doUpdate = true;
                                }
                                if (doUpdate) {
                                    jobIds.push(chunk.jobId);
                                }
                            }
                        }
                    }

                    if (jobIds.length > 0) {
                        Visualforce.remoting.Manager.invokeAction(
                            "{!$RemoteAction.HyperBatchCon.getAsyncJobStatus}",
                            jobIds,
                            function (result, event) {
                                console.log("getAsyncJobStatus result, event");
                                console.log(result);
                                console.log(event);

                                for (var i = 0; i < result.length; i++) {
                                    var job = result[i];
                                    var jobId15 = job.Id.substring(0, 15);

                                    //we are going to make one of our own status.  If status is Failed and, but extended status
                                    //contains UNABLE_TO_LOCK_ROW, we are going to re-name the status to RowLocked
                                    var isRowLock = false;
                                    if (job.Status == "Failed") {
                                        if (job.ExtendedStatus != null) {
                                            if (job.ExtendedStatus.indexOf("UNABLE_TO_LOCK_ROW") != -1) {
                                                isRowLock = true;
                                            }
                                        }
                                    }

                                    if (isRowLock) {
                                        job.Status = "RowLocked";

                                        //get the index location
                                        var startAt;
                                        for (var j = 0; j < chunkList[type].length; j++) {
                                            var chunk = chunkList[type][j];
                                            if (chunk.jobId == jobId15) {
                                                startAt = j;
                                                break;
                                            }
                                        }
                                        doChunk(startAt, type);
                                    }

                                    //update the dom
                                    $("#" + jobId15).html(job.Status);

                                    //update the JS object
                                    for (var j = 0; j < chunkList[type].length; j++) {
                                        var chunk = chunkList[type][j];
                                        if (chunk.jobId == jobId15) {
                                            chunk.AsyncApexJobStatus = job.Status;
                                        }
                                    }
                                }

                                setTimeout(function () {
                                    checkAsyncJobs(type);
                                }, 5000);
                            },
                            { escape: false, buffer: false }
                        );
                    } else {
                        runBatchFinish(type);
                    }
                }

                function runBatchFinish(type) {
                    console.log("runBatchFinish: " + type);

                    var startTime = batchClassMap[type].startTimestamp;
                    var endTime = new Date().getTime();
                    elapsed = endTime - startTime;
                    elapsedSeconds = Math.floor(elapsed / 1000);
                    console.log("*** all " + type + " chunks complete.  elapsed seconds: " + elapsedSeconds);

                    $("#status_" + type).prepend("<p>Done in " + elapsedSeconds + " seconds.</p>");
                    $("#art_" + type).css("background", "#7cc27e");

                    if (batchClassMap[type].isAsync) {
                        //Async finish method

                        //get all the job Ids
                        var jobIds = [];
                        for (var i = 0; i < chunkList[type].length; i++) {
                            var chunk = chunkList[type][i];
                            if ("jobId" in chunk) {
                                if (chunk.jobId != null) {
                                    jobIds.push(chunk.jobId);
                                }
                            }
                        }

                        Visualforce.remoting.Manager.invokeAction(
                            "{!$RemoteAction.HyperBatchCon.doHyperBatchFinishAsync}",
                            type,
                            jobIds,
                            function (result, event) {
                                console.log("doHyperBatchFinishAsync result, event");
                                console.log(result);
                                console.log(event);
                            },
                            { escape: false, buffer: false }
                        );
                    } else {
                        //Sync finish method

                        //convert the state map into a state array
                        var arrState = [];
                        var stateMap = batchClassMap[type].state;
                        for (var key in stateMap) {
                            if (stateMap.hasOwnProperty(key)) {
                                arrState.push(stateMap[key]);
                            }
                        }

                        console.log("runBatchFinish sync", arrState);

                        Visualforce.remoting.Manager.invokeAction(
                            "{!$RemoteAction.HyperBatchCon.doHyperBatchFinishSync}",
                            type,
                            JSON.stringify(arrState),
                            function (result, event) {
                                console.log("doHyperBatchFinishSync result, event");
                                console.log(result);
                                console.log(event);
                            },
                            { escape: false, buffer: false }
                        );
                    }
                }

                function doChunk(startAt, type) {
                    var firstId = chunkList[type][startAt].first;
                    var lastId = chunkList[type][startAt].last;
                    var isLast = chunkList[type][startAt].isLast;
                    var guid = chunkList[type][startAt].guid;
                    var query = batchClassMap[type].query;

                    var context = { batchClassName: type, num: startAt, guid: guid };

                    var remoteCallback = function (result, event) {
                        handleRemoteResponse(this, result, event);
                    };
                    var remoteCallbackWithContext = remoteCallback.bind(context);

                    var executeMethod = batchClassMap[type].isAsync
                        ? "{!$RemoteAction.HyperBatchCon.executeAsync}"
                        : "{!$RemoteAction.HyperBatchCon.executeSync}";

                    if (batchClassMap[type].isAsync) {
                        Visualforce.remoting.Manager.invokeAction(
                            "{!$RemoteAction.HyperBatchCon.executeAsync}",
                            firstId,
                            lastId,
                            isLast,
                            query,
                            type,
                            remoteCallbackWithContext,
                            { escape: false, buffer: false }
                        );
                    } else {
                        Visualforce.remoting.Manager.invokeAction(
                            "{!$RemoteAction.HyperBatchCon.executeSync}",
                            firstId,
                            lastId,
                            isLast,
                            query,
                            type,
                            generateUUID(),
                            remoteCallbackWithContext,
                            { escape: false, buffer: false }
                        );
                    }
                }

                function handleRemoteResponse(context, result, event) {
                    console.log("handleRemoteResponse context result event");
                    console.log(context);
                    console.log(result);
                    console.log(event);

                    var batchClassName = context.batchClassName;
                    var guid = context.guid;
                    var startAt = context.num;

                    //trap any timeouts, etc.  see if we need to retry.
                    var doRetry = checkRetry(event);
                    if (doRetry == false) {
                        checkErrors(event, guid);
                    }

                    if (event.status) {
                        chunkComplete(context, result);
                    }

                    if (doRetry) {
                        if (!(batchClassName in chunkRetries)) {
                            chunkRetries[batchClassName] = {};
                        }

                        if (startAt in chunkRetries[batchClassName]) {
                            chunkRetries[batchClassName][startAt]++;
                        } else {
                            chunkRetries[batchClassName][startAt] = 1;
                        }

                        if (chunkRetries[batchClassName][startAt] <= numberOfRetries) {
                            console.log("retry: " + chunkRetries[batchClassName][startAt]);
                            updateBatchRetry(guid);
                            doChunk(startAt, batchClassName);
                        } else {
                            //we hit our number of retries, time to fail
                            checkErrors(event, guid);
                            chunkComplete(context, result);
                        }
                    }
                }

                function checkRetry(event) {
                    var doRetry = false;
                    if (event.type === "exception") {
                        if (
                            event.message.indexOf("timeout") > -1 ||
                            event.message.indexOf("UNABLE_TO_LOCK_ROW") > -1 ||
                            event.message.indexOf("ConcurrentPerOrgApex") > -1 ||
                            event.message.indexOf("Remoting request invalid for your session") > -1 ||
                            event.message.indexOf("Logged in") > -1
                        ) {
                            doRetry = true;
                        }
                    }
                    return doRetry;
                }

                //=========================================================
                // END execute chunks
                //=========================================================

                //=========================================================
                // BEGIN methods to query for HyperBatch apex classes
                //=========================================================
                function getApexClasses() {
                    var query = encodeURIComponent("SELECT SymbolTable FROM ApexClass");

                    //calls Salesforce Tooling API with jQuery
                    $.ajax({
                        type: "GET",
                        url: "/services/data/v37.0/tooling/query/?q=" + query,
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader("Authorization", "Bearer {!$Api.Session_ID}");
                            xhr.setRequestHeader("Content-Type", "application/json");
                            xhr.setRequestHeader("Access-Control-Allow-Origin", "*");
                            xhr.setRequestHeader("Access-Control-Allow-Methods", "GET");
                        },
                        success: function (data) {
                            findHyperBatchClasses(data);
                        },
                        error: function (XMLHttpRequest, textStatus, errorThrown) {
                            console.log("ERROR: " + textStatus + ", " + errorThrown + ". " + JSON.stringify(XMLHttpRequest));
                        }
                    });
                }

                function findHyperBatchClasses(data) {
                    //console.log('findHyperBatchClasses data:');
                    //console.log(data);

                    hyperBatchClasses = [];

                    for (var i = 0; i < data.records.length; i++) {
                        var record = data.records[i];
                        var className = record.SymbolTable.name;
                        //console.log('findHyperBatchClasses record');
                        //console.log(record);
                        if ("SymbolTable" in record) {
                            var rst = record.SymbolTable;
                            if ("interfaces" in rst) {
                                for (var j = 0; j < rst.interfaces.length; j++) {
                                    if (rst.interfaces[j].toLowerCase() == "hyperbatch") {
                                        hyperBatchClasses.push(className);
                                    }
                                }
                            }
                        }
                    }
                    hyperBatchClasses.sort();
                    renderClasses();
                }

                //=========================================================
                // END methods to query for HyperBatch apex classes
                //=========================================================

                //=========================================================
                // BEGIN common methods
                //=========================================================

                function addBatchStatus(batchClassName, chunk) {
                    var status = '<p id="' + chunk.guid + '">Batch: ' + chunk.num + " / " + chunk.total + ".  Requested...";
                    $("#status_" + batchClassName).append(status);
                }
                function updateBatchStatus(context, response) {
                    var isSuccess = true;
                    var status = "";
                    var jobId;
                    if (response != null) {
                        isSuccess = response.success;
                        jobId = response.jobId;
                        chunkList[context.batchClassName][context.num].jobId = jobId;
                        if (!response.success) {
                            status = response.msg;
                        }
                    } else {
                        isSuccess = false;
                        status = "Max Retries.";
                    }
                    var statusMsg = "";
                    if (!batchClassMap[context.batchClassName].isAsync) {
                        statusMsg = "Completed";
                    }

                    if (jobId != null) {
                        $("#" + context.guid).append("<span id='" + jobId + "'>" + statusMsg + "</span>");
                    }

                    $("#" + context.guid).append(status);
                }
                function updateBatchRetry(guid) {
                    var status = "Retry...";
                    $("#" + guid).append(status);
                }

                var updateStatus = function (msgLocation, statusMsg) {
                    console.log("STATUS: " + msgLocation + ", " + statusMsg);
                };

                var checkErrors = function (event, guid) {
                    var errorMsg;
                    if (event.status) {
                        //do nothing, no error
                    } else if (event.type === "exception") {
                        errorMsg = event.message + " : " + event.type;
                    } else {
                        errorMsg = event.message;
                    }
                    if (errorMsg != null) {
                        console.log("ERROR: " + errorMsg);
                        $("#" + guid).append(errorMsg);
                    }
                };

                function generateUUID() {
                    var d = new Date().getTime();
                    if (window.performance && typeof window.performance.now === "function") {
                        d += performance.now(); //use high-precision timer if available
                    }
                    var uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
                        var r = (d + Math.random() * 16) % 16 | 0;
                        d = Math.floor(d / 16);
                        return (c == "x" ? r : (r & 0x3) | 0x8).toString(16);
                    });
                    return uuid;
                }
                //=========================================================
                // END common methods
                //=========================================================
            </script>
        </head>

        <body>
            <div class="hb">
                <div class="slds-page-header" role="banner">
                    <div class="slds-grid">
                        <div class="slds-col slds-has-flexi-truncate">
                            <div class="slds-media slds-no-space slds-grow">
                                <div class="slds-media__figure">
                                    <svg aria-hidden="true" class="slds-icon slds-icon-custom-custom80">
                                        <use
                                            xlink:href="{!URLFOR($Resource.slds, 'assets/icons/custom-sprite/svg/symbols.svg#custom80')}"
                                        ></use>
                                    </svg>
                                </div>
                                <div class="slds-media__body">
                                    <p class="slds-text-title--caps slds-line-height--reset">Batch Runner</p>
                                    <h1 class="slds-page-header__title slds-m-right--small slds-align-middle slds-truncate" title="Batch">
                                        HyperBatch
                                    </h1>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="statusColumns" class="slds-grid" style="padding: 10px">
                    <div id="" align="center">
                        <button class="slds-button slds-button--neutral" style="margin: 5px" onclick="runAsync();">
                            <svg aria-hidden="true" class="slds-button__icon slds-button__icon--left">
                                <use
                                    xlink:href="{!URLFOR($Resource.slds, 'assets/icons/utility-sprite/svg/symbols.svg#standard_objects')}"
                                ></use></svg
                            >Run Async
                        </button>
                        <button class="slds-button slds-button--neutral" style="margin: 5px" onclick="runSync();">
                            <svg aria-hidden="true" class="slds-button__icon slds-button__icon--left">
                                <use xlink:href="{!URLFOR($Resource.slds, 'assets/icons/utility-sprite/svg/symbols.svg#sync')}"></use></svg
                            >Run Sync
                        </button>
                        <div class="slds-form--horizontal">
                            <div class="slds-form-element">
                                <label class="slds-form-element__label" for="chunkSize">Batch Size</label>
                                <div class="slds-form-element__control" style="padding-bottom: 5px">
                                    <input type="text" id="chunkSize" class="slds-input" style="width: 161px" value="2000" />
                                </div>
                            </div>
                        </div>
                        <div id="classes" />
                    </div>
                </div>
            </div>
        </body>
    </html>
</apex:page>
